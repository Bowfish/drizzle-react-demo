{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter,\n    util = require('util'),\n    eachSeries = require('async/eachSeries'),\n    AsyncEventEmitter;\n\nmodule.exports = exports = AsyncEventEmitter = function AsyncEventEmitter() {\n  EventEmitter.call(this);\n};\n\nutil.inherits(AsyncEventEmitter, EventEmitter);\n/* Public methods\n============================================================================= */\n\nAsyncEventEmitter.prototype.emit = function (event, data, callback) {\n  var self = this,\n      listeners = self._events[event] || []; // Optional data argument\n\n  if (!callback && typeof data === 'function') {\n    callback = data;\n    data = undefined;\n  } // Special treatment of internal newListener and removeListener events\n\n\n  if (event === 'newListener' || event === 'removeListener') {\n    data = {\n      event: data,\n      fn: callback\n    };\n    callback = undefined;\n  } // A single listener is just a function not an array...\n\n\n  listeners = Array.isArray(listeners) ? listeners : [listeners];\n  eachSeries(listeners.slice(), function (fn, next) {\n    var err; // Support synchronous functions\n\n    if (fn.length < 2) {\n      try {\n        fn.call(self, data);\n      } catch (e) {\n        err = e;\n      }\n\n      return next(err);\n    } // Async\n\n\n    fn.call(self, data, next);\n  }, callback);\n  return self;\n};\n\nAsyncEventEmitter.prototype.once = function (type, listener) {\n  var self = this,\n      _g2;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  } // Hack to support set arity\n\n\n  if (listener.length >= 2) {\n    _g2 = function g(e, next) {\n      self.removeListener(type, _g2);\n      listener(e, next);\n    };\n  } else {\n    _g2 = function _g(e) {\n      self.removeListener(type, _g2);\n      listener(e);\n    };\n  }\n\n  _g2.listener = listener;\n  self.on(type, _g2);\n  return self;\n};\n\nAsyncEventEmitter.prototype.first = function (event, listener) {\n  var listeners = this._events[event] || []; // Contract\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  } // Listeners are not always an array\n\n\n  if (!Array.isArray(listeners)) {\n    this._events[event] = listeners = [listeners];\n  }\n\n  listeners.unshift(listener);\n  return this;\n};\n\nAsyncEventEmitter.prototype.at = function (event, index, listener) {\n  var listeners = this._events[event] || []; // Contract\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  }\n\n  if (typeof index !== 'number' || index < 0) {\n    throw new TypeError('index must be a non-negative integer');\n  } // Listeners are not always an array\n\n\n  if (!Array.isArray(listeners)) {\n    this._events[event] = listeners = [listeners];\n  }\n\n  listeners.splice(index, 0, listener);\n  return this;\n};\n\nAsyncEventEmitter.prototype.before = function (event, target, listener) {\n  return this._beforeOrAfter(event, target, listener);\n};\n\nAsyncEventEmitter.prototype.after = function (event, target, listener) {\n  return this._beforeOrAfter(event, target, listener, 'after');\n};\n/* Private methods\n============================================================================= */\n\n\nAsyncEventEmitter.prototype._beforeOrAfter = function (event, target, listener, beforeOrAfter) {\n  var listeners = this._events[event] || [],\n      i,\n      index,\n      add = beforeOrAfter === 'after' ? 1 : 0; // Contract\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  }\n\n  if (typeof target !== 'function') {\n    throw new TypeError('target must be a function');\n  } // Listeners are not always an array\n\n\n  if (!Array.isArray(listeners)) {\n    this._events[event] = listeners = [listeners];\n  }\n\n  index = listeners.length;\n\n  for (i = listeners.length; i--;) {\n    if (listeners[i] === target) {\n      index = i + add;\n      break;\n    }\n  }\n\n  listeners.splice(index, 0, listener);\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}